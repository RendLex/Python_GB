# 3. Написать декоратор для логирования(вывод в консоль) типов позиционных аргументов функции:
# Техническое задание:
# 
# Если аргументов несколько - выводить данные о каждом через запятую.
# Все выводы должны быть внутри функции-обертки/задекорированной функции
# После того как вы «обернули»/«задекорировали» функцию убедитесь что и аргументы, и возвращаемое значение остались как у исходной функции. Т.е. вызов задекорированной функции ничем не отличается от вызова исходной функции, результат возвращается такой же, но добавляется печать в консоль.
# Усложнение:
#
# вывести тип возвращаемого значения функции
# решить задачу для именованных аргументов
# вывести имя функции
def type_logger(func):
    def wrapper(*args, **kwargs):
        print(f"Фунция: {func.__name__}")
        print(", ".join([f"{i}: {type(i)}" for i in args]))
        if len(kwargs) > 0:
            print(", ".join([f"'{key}' = {val}: {type(val)}" for key, val in kwargs.items()]), end='\n\n')
        result = func(*args)
        print(f"Результат: {result}  тип: {type(result)}", end='\n\n')
        return result
    return wrapper

@type_logger
def render_input(*args, **kwargs):
   return 1

@type_logger
def calc_cube(x):
   return x**3

render_input(1,2,-3)
render_input(1,2,"new")
render_input(1, a = 2, b = True, c = "q")

calc_cube(55)
